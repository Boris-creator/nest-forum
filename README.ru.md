![StandWithUkraine](https://raw.githubusercontent.com/vshymanskyy/StandWithUkraine/main/badges/StandWithUkraine.svg)
## Стэк ##
Бэкенд реализован на Nest.js, фронтенд на Angular.

Многие отмечают сходство архитектур Nest и Angular, проявляющееся на разных уровнях — от реализации внедрения зависимостей до организации потоков данных.
Как известно, Angular использует RxJs как в ядре, так и в интерфейсе. Точно также методы RxJS находят широкое применение в серверной части. Так, метод `handle` интерцепторов Nest возвращает объект интерфейса `Observable`. Далее, использование event emitter а Node.js позволяет выстроить событийную архитектуру серверного приложения, в которой можно эффективно использовать мощные методы RxJS.
В данном проекте эмиттер используется в реализации системы пользовательских уведомлений; это позволяет избежать внедрения дополнительных зависимостей в самые разные классы, ответственные за действия, которые должны фиксироваться в уведомлениях; что в свою очередь поддерживает слабую связанность системы. Логика фильтрации событий (например, в зависимости от параметров события и пользовательских настроек), генерации, хранения и форматирования сообщений реализована средствами RxJS.
Грубый пример:
```typescript
const t = this;
const notification = fromEvent(this.emitter, Notify.deleteComment);
notification
    .pipe(
        filter((note: any) => {
            return note.comment.authorId !== note.deletedBy.id; // ...здесь можно отфильтровать события, не создавая для некоторых из них уведомления
        }),
        map((note: any) => {
            // ...здесь можно структурировать данные, которые будут содержаться в уведомлении 
        }),
    )
    .subscribe({
        next(data) {
            t.notify(data);
        },
    });
```
Одной из важных технических задач при разработке монолитного проекта является правильная организация совместной работы фронтенда и бэкенда для поддержания их согласованности. Я имею в виду, что любое изменение сигнатур методов, вызываемых на стороне сервера запросами к API, должно повлечь за собой изменение структур данных, отправляемых и принимаемых клиентом. При правильной организации кода проекта необходимость внесения изменений должна становиться очевидной разработчику автоматически, и при этом дублирование кода в разных частях проекта должно быть минимизировано. Возможную эффективную реализацию этой задачи предлагает библиотека tRPC. Я решаю задачу проще — импортирую в модули серверной и клиентской частей одни и те же декларации типов и структуры. В частности, общие схемы [Zod](https://zod.dev/) позволяют автоматически поддерживать единство  правил валидации на клиенте и на сервере.

Общая для всего приложения система типов, будучи правильно спроектированной, обеспечивает согласованность Api сервера и запросов клиента.

В основе реализации валидации входящих данных лежит базовая идея модификации доступа к свойствам модели данных. В нативном JS это можно осуществить, введя сеттер для параметра, который и будет заключать в себе всю логику проверки и в случае успеха записывать новое значение параметра, а в случае провала (опционально) выбрасывать исключение. В TS такой сеттер естественно создать в рамках декоратора свойства класса или параметра метода. По такой схеме работает и инструментарий для валидации и преобразования данных запроса в Nest — Pipes: синтаксически pipes выступают как декораторы параметров запроса. Однако пайпы вообще говоря не имеют прямого доступа к самому объекту запроса, поэтому часть валидации бывает удобнее вынести в интерцепторы, которые имеют полный доступ к контексту выполнения.

## Коротко о проекте. ##
Многопользовательская платформа, где участники могут публиковать сущности (будь то тексты, видеоролики или задачи по кодингу), оценивать и обсуждать сущности, размещенные другими участниками.
Сущности проходят премодерацию, комментарии могут редактироваться и удаляться участниками с модераторскими правами.
